<template>
  <b-modal
      :title="$t('modal.previewJava.title')"
      centered
      size="lg"
      :ok-title="$t('button.dismiss')"
      :cancel-title="$t('button.copy')"
      ok-variant="primary"
      cancel-variant="secondary"
      :cancel-disabled="false"
      @cancel.prevent="onCopy">
    <div ref="codeContainer" class="code-container">
      <highlight-code lang="java" :code="javaCode" />
    </div>
  </b-modal>
</template>

<script>
import pkg from "../../../package.json"

import stringUtils from '../../utils/stringUtils';
import fileUtils from '../../utils/fileUtils';

export default {
  name: "JavaPreviewModal",
  data() {
    return {
      template: "",
      zipObject: {},
      javaCode: ""
    }
  },
  methods: {
    onCopy() {
      this.$copyText(this.javaCode, this.$refs.codeContainer)
      .then(() => this.$alertify.success(this.$t("modal.javaPreview.copied")),
            () => this.$alertify.success(this.$t("modal.javaPreview.copyFailed")));
    },
    showModal(template, zipObject) {
      if (template == null || zipObject == null) {
        return new Promise((r, reject) => reject("null reference"));
      }
      this.template = template;
      this.zipObject = zipObject;
      this.javaCode = this.$t("modal.javaPreview.generating");
      this.generateCode(template, zipObject)
      .then(val => {
        this.javaCode = val;
      }, err => {
        this.javaCode = this.$t("modal.javaPreview.failedGenerating") + err;
        console.error(err);
      });
      this.$children[0].show()
    },
    generateCode(template, projectObject) {
      return new Promise(resolve => {
        let generateInfo = ""
          + "/**\n"
          + " * This file is generated by ListView Generator(" + pkg.version + ") by ColinTree\n"
          + " * Find more infomation on github: https://github.com/ColinTree/ListViewGenerator \n"
          + " * Generate time: " + new Date(Date.now()) + "\n"
          + " * Browser: " + navigator.userAgent + "\n"
          + " * Location: " + window.location + "\n"
          + " */\n";

        let content = template;
        let projectInfo = projectObject.projectInfo;
        let itemLayout = projectObject.itemLayout;
        if (itemLayout == null) {
          throw "No itemlayout provided";
        }

        // replace globally: __xxx__
        content = stringUtils.replaceAllInObj(content, {
          "__componentName__": projectInfo.componentName,
          "__version__": projectInfo.version,
          "__fullPackage__": projectInfo.fullPackage,
          "__description__": projectInfo.description
        });

        // replace blocks: /*_block_name_start_*/ ... /*_block_name_end_*/
        function handleBlock(content, blockName, handler) {
          try {
            let split = stringUtils.strictSplit(content, [ "/*_block_"+blockName+"_start_*/", "/*_block_"+blockName+"_end_*/" ]);
            let beforeBlock = split[0] + "/* GENERATED BLOCK START: " + blockName + " */";
            let blockFormat = split[1];
            let afterBlock = "/* GENERATED BLOCK END:   " + blockName + " */" + split[2];
            handler(beforeBlock, blockFormat, afterBlock);
          } catch (e) {
            throw "Template error: " + e;
          }
        }
        // replace plot: /*_plot_name_*/
        function handlePlot(content, plotName, handler) {
          try {
            let split = stringUtils.strictSplit(content, "/*_plot_"+plotName+"_*/");
            let linePrefix = split[0].substr(split[0].lastIndexOf("\n") + 1);
            let beforePlot = split[0] + "/* GENERATED PLOT START: " + plotName + " */\n" + linePrefix;
            let afterPlot = "/* GENERATED PLOT END:   " + plotName + " */" + split[1];
            handler(beforePlot, linePrefix, afterPlot);
          } catch (e) {
            throw "Template error: " + e;
          }
        }
        handleBlock(content, "propertyDefaultValue", (beforeBlock, blockFormat, afterBlock) => {
          for (let name in projectInfo.properties) {
            let property = projectInfo.properties[name];
            beforeBlock += stringUtils.replaceAllInObj(blockFormat, {
              "_type_": property.javaType,
              "_name_": name,
              "_defaultValue_": property.defaultValue
            });
          }
          content = beforeBlock + afterBlock;
        });
        handleBlock(content, "propertyField", (beforeBlock, blockFormat, afterBlock) => {
          for (let name in projectInfo.properties) {
            let property = projectInfo.properties[name];
            beforeBlock += stringUtils.replaceAllInObj(blockFormat, {
              "_type_": property.javaType,
              "_name_": name
            });
          }
          content = beforeBlock + afterBlock;
        });
        handleBlock(content, "property", (beforeBlock, blockFormat, afterBlock) => {
          for (let name in projectInfo.properties) {
            let property = projectInfo.properties[name];
            beforeBlock += stringUtils.replaceAllInObj(blockFormat, {
              "_description_": property.description,
              "_category_": property.category,
              "/*_lineIf_designerVisible_*/": property.designerVisible ? "" : "//",
              "_setterVisible_": property.setterVisible,
              "_editorType_": property.editorType,
              "_args_": (() => {
                let rtn = "{";
                let first = true;
                for (let argIndex in property.args) {
                  first ? first = false : rtn += ", ";
                  rtn += "\"" + property.args[argIndex] + "\"";
                }
                return rtn + "}";
              })(),
              "_type_": property.javaType,
              "_name_": name,
              "_getterVisible_": property.getterVisible
            });
          }
          content = beforeBlock + afterBlock;
        });
        handleBlock(content, "elementComponent", (beforeBlock, blockFormat, afterBlock) => {
          function traverseComponentContainer(compProps) {
            for (let childIndex in compProps["$Components"]) {
              let child = compProps["$Components"][childIndex];
              beforeBlock += stringUtils.replaceAllInObj(blockFormat, {
                "_type_": child["$Type"],
                "_name_": child["$Name"]
              });
              if (child["$Components"] != null) {
                traverseComponentContainer(child);
              }
            }
          }
          traverseComponentContainer(itemLayout["Properties"]);
          content = beforeBlock + afterBlock;
        });
        handlePlot(content, "elementCreate", (beforePlot, linePrefix, afterPlot) => {
          function println(line = "") {
            beforePlot += line + "\n" + linePrefix;
          };
          // FIXME: Handle different default values in different platforms
          function traverseComponentContainer(compProps) {
            let containerName = compProps["$Type"] == "Form" ? "container" : compProps["$Name"];
            for (let childIndex in compProps["$Components"]) {
              let child = compProps["$Components"][childIndex];
              println(stringUtils.replaceAllInObj("_name_ = new _type_(_container_);", {
                "_type_": child["$Type"],
                "_name_": child["$Name"],
                "_container_": containerName
              }));
              for (let propName in child) {
                if (propName.charAt(0) != "$" && propName != "Uuid" && child.hasOwnProperty(propName)) {
                  println(stringUtils.replaceAllInObj("setProperty(_name_, \"_propName_\", \"_propValue_\");", {
                    "_name_": child["$Name"],
                    "_propName_": propName,
                    "_propValue_": child[propName]
                  }));
                }
              }
              println();
              if (child["$Components"] != null) {
                traverseComponentContainer(child);
              }
            }
          }
          traverseComponentContainer(itemLayout["Properties"]);
          content = beforePlot + afterPlot;
        });
        handlePlot(content, "elementShow", (beforePlot, linePrefix, afterPlot) => {
            for (let childIndex in itemLayout["Properties"]["$Components"]) {
              let child = itemLayout["Properties"]["$Components"][childIndex];
              beforePlot += stringUtils.replaceAllInObj("setProperty(_name_, \"Visible\", \"true\");", {
                "_name_": child["$Name"]
              });
              beforePlot += "\n" + linePrefix;
            }
            content = beforePlot + afterPlot;
        });
        handlePlot(content, "elementHide", (beforePlot, linePrefix, afterPlot) => {
            for (let childIndex in itemLayout["Properties"]["$Components"]) {
              let child = itemLayout["Properties"]["$Components"][childIndex];
              beforePlot += stringUtils.replaceAllInObj("setProperty(_name_, \"Visible\", \"false\");", {
                "_name_": child["$Name"]
              });
              beforePlot += "\n" + linePrefix;
            }
            content = beforePlot + afterPlot;
        });

        // TODO:

        setTimeout(() => resolve(generateInfo + content), 1000);
      });
    }
  }
}
</script>

<style>
.code-container {
  height: 70vh;
}
.code-container pre {
  height: 100%;
}
.code-container code {
  width: fit-content;
  overflow: unset;
}
</style>