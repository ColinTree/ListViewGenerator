<template>
  <b-modal
      :title="$t('modal.previewJava.title')"
      centered
      size="lg"
      :ok-title="$t('button.dismiss')"
      :cancel-title="$t('button.copy')"
      ok-variant="primary"
      cancel-variant="secondary"
      :cancel-disabled="false"
      @cancel.prevent="onCopy">
    <div ref="codeContainer" class="code-container">
      <highlight-code lang="java" :code="javaCode" />
    </div>
  </b-modal>
</template>

<script>
import pkg from "../../../package.json"

import stringUtils from '../../utils/stringUtils';

export default {
  name: "JavaPreviewModal",
  data() {
    return {
      template: "",
      zipObject: {},
      javaCode: ""
    }
  },
  methods: {
    onCopy() {
      this.$copyText(this.javaCode, this.$refs.codeContainer)
      .then(() => this.$alertify.success(this.$t("modal.javaPreview.copied")),
            () => this.$alertify.success(this.$t("modal.javaPreview.copyFailed")));
    },
    showModal(template, zipObject) {
      if (template == null || zipObject == null) {
        return new Promise((r, reject) => reject("null reference"));
      }
      this.template = template;
      this.zipObject = zipObject;
      this.javaCode = this.$t("modal.javaPreview.generating");
      this.generateCode(template, zipObject)
      .then(val => {
        this.javaCode = val;
      }, err => {
        this.javaCode = this.$t("modal.javaPreview.failedGenerating") + err;
      });
      this.$children[0].show()
    },
    generateCode(template, zipObject) {
      return new Promise((resolve, reject) => {
        let generateInfo = ""
          + "/**\n"
          + " * This file is generated by ListView Generator(" + pkg.version + ") by ColinTree\n"
          + " * Find more infomation on github: https://github.com/ColinTree/ListViewGenerator \n"
          + " * Generate time: " + new Date(Date.now()) + "\n"
          + " * Browser: " + navigator.userAgent + "\n"
          + " * Location: " + window.location + "\n"
          + " */\n";

        let content = template;
        let projectInfo = zipObject.projectInfo;

        // replace globally: __xxx__
        content = stringUtils.replaceAllInObj(content, {
          "__componentName__": projectInfo.componentName,
          "__version__": projectInfo.version,
          "__fullPackage__": projectInfo.fullPackage,
          "__description__": projectInfo.description
        });

        // replace blocks: /*_blockStart_*/
        function handleBlock(content, blockName, reject, handler) {
          let split = content.split("/*_"+blockName+"Start_*/");
          switch (split.length) {
              case 1:  return reject("Template error: \"" + blockName + "\" start block not found");
              case 2:  break;
              default: return reject("Template error: more than one \"" + blockName + "\" start block is found");
          }
          let beforeBlock = split[0] + "/* GENERATED BLOCK START: " + blockName + " */";
          split = split[1].split("/*_"+blockName+"End_*/");
          switch (split.length) {
              case 1:  return reject("Template error: \""+blockName+"\" end block not found");
              case 2:  break;
              default: return reject("Template error: more than one \""+blockName+"\" end block is found");
          }
          let blockFormat = split[0];
          let afterBlock = "/* GENERATED BLOCK END:   " + blockName + " */" + split[1];
          handler(beforeBlock, blockFormat, afterBlock);
        }
        handleBlock(content, "propertyDefaultValue", reject, (beforeBlock, blockFormat, afterBlock) => {
          for (let name in projectInfo.properties) {
            let property = projectInfo.properties[name];
            beforeBlock += stringUtils.replaceAllInObj(blockFormat, {
              "_type_": property.javaType,
              "_name_": name,
              "_defaultValue_": property.defaultValue
            });
          }
          content = beforeBlock + afterBlock;
        });
        handleBlock(content, "propertyField", reject, (beforeBlock, blockFormat, afterBlock) => {
          for (let name in projectInfo.properties) {
            let property = projectInfo.properties[name];
            beforeBlock += stringUtils.replaceAllInObj(blockFormat, {
              "_type_": property.javaType,
              "_name_": name
            });
          }
          content = beforeBlock + afterBlock;
        });
        handleBlock(content, "property", reject, (beforeBlock, blockFormat, afterBlock) => {
          for (let name in projectInfo.properties) {
            let property = projectInfo.properties[name];
            beforeBlock += stringUtils.replaceAllInObj(blockFormat, {
              "_description_": property.description,
              "_category_": property.category,
              "_if_designerVisible_": property.designerVisible ? "" : "//",
              "_setterVisible_": property.setterVisible,
              "_editorType_": property.editorType,
              "_args_": "{\"" + property.args.join("\", \"") + "\"}",
              "_type_": property.javaType,
              "_name_": name,
              "_getterVisible_": property.getterVisible
            });
          }
          content = beforeBlock + afterBlock;
        });

        // TODO:

        setTimeout(() => resolve(generateInfo + content), 1000);
      });
    }
  }
}
</script>

<style>
.code-container {
  height: 70vh;
}
.code-container pre {
  height: 100%;
}
.code-container code {
  width: fit-content;
  overflow: unset;
}
</style>