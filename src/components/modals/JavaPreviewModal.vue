<template>
  <b-modal
      centered
      size="lg"
      ok-variant="primary"
      cancel-variant="secondary"
      @cancel.prevent="onCopy">
    <span slot="modal-title" v-t="'modal.previewJava.title'" />
    <span slot="modal-ok" v-t="'button.dismiss'" />
    <span slot="modal-cancel" v-t="'button.copy'" />
    <div ref="codeContainer" class="code-container">
      <highlight-code :code="javaCode" auto />
    </div>
  </b-modal>
</template>

<script lang="ts">
import { Vue, Component } from 'vue-property-decorator'
import { BModal } from 'bootstrap-vue'

import pkg from '../../../package.json'

import StringUtils from '../../utils/StringUtils'
import FileUtils, { ZipObject } from '../../utils/FileUtils'
import { LvgProjectObject, LvgItemLayout, EmptyAiaScmFile } from '../../typings/lvg'
import { GITHUB_REPO_FULL_URL } from '../../const'

@Component
export default class JavaPreviewModal extends Vue {
  private javaCode = ''

  public async showModal (template: string, projectObject: LvgProjectObject) {
    (this.$children[0] as BModal).show()
    if (template === null || projectObject === null) {
      return new Promise((r, reject) => reject('null reference'))
    }
    this.javaCode = this.$t('modal.javaPreview.generating') as string
    try {
      this.javaCode = await this.generateCode(template, projectObject)
    } catch (err) {
      this.javaCode = this.$t('modal.javaPreview.failedGenerating') + err
      console.error(err)
    }
  }
  public async generateCode (template: string, projectObject: LvgProjectObject): Promise<string> {
    const generateInfo = '' +
      '/**\n' +
      ` * This file is generated by ListView Generator(${pkg.version}) by ColinTree\n` +
      ` * Find more infomation on github: ${GITHUB_REPO_FULL_URL} \n` +
      ` * Generate time: ${new Date(Date.now())}\n` +
      ` * Browser: ${navigator.userAgent}\n` +
      ` * Location: ${window.location}\n` +
      ' */\n'

    const itemLayout = projectObject.itemLayout
    const properties = projectObject.properties

    let content = template
    if (itemLayout === undefined) {
      throw new Error('No itemlayout provided')
    }

    // replace globally: __xxx__
    content = StringUtils.replaceAllInObj(content, {
      __componentName__: projectObject.componentName,
      __version__: String(projectObject.version),
      __fullPackage__: projectObject.fullPackage,
      __description__: projectObject.description
    })

    // replace blocks: /*_block_name_start_*/ ... /*_block_name_end_*/
    function handleBlock (
        blockName: string,
        handler: (beforeBlock: string, blockFormat: string, afterBlock: string) => void) {
      try {
        const split = StringUtils.strictSplit(content, [
          `/*_block_${blockName}_start_*/`,
          `/*_block_${blockName}_end_*/`
        ])
        const beforeBlock = split[0] + `/* GENERATED BLOCK START: ${blockName} */`
        const blockFormat = split[1]
        const afterBlock =             `/* GENERATED BLOCK END:   ${blockName} */` + split[2]
        handler(beforeBlock, blockFormat, afterBlock)
      } catch (e) {
        throw new Error('Template error: ' + e)
      }
    }
    // replace plot: /*_plot_name_*/
    function handlePlot (
          plotName: string,
          handler: (beforePlot: string, linePrefix: string, afterPlot: string) => void) {
      try {
        const split = StringUtils.strictSplit(content, `/*_plot_${plotName}_*/`)
        const linePrefix = split[0].substr(split[0].lastIndexOf('\n') + 1)
        const beforePlot = split[0] + `/* GENERATED PLOT START: ${plotName} */\n` + linePrefix
        const afterPlot =             `/* GENERATED PLOT END:   ${plotName} */` + split[1]
        handler(beforePlot, linePrefix, afterPlot)
      } catch (e) {
        throw new Error('Template error: ' + e)
      }
    }
    handleBlock('propertyDefaultValue', (beforeBlock, blockFormat, afterBlock) => {
      for (const name in properties) {
        const property = properties[name]
        beforeBlock += StringUtils.replaceAllInObj(blockFormat, {
          _type_: property.javaType,
          _name_: name,
          _defaultValue_: property.defaultValue
        })
      }
      content = beforeBlock + afterBlock
    })
    handleBlock('propertyField', (beforeBlock, blockFormat, afterBlock) => {
      for (const name in properties) {
        const property = properties[name]
        beforeBlock += StringUtils.replaceAllInObj(blockFormat, {
          _type_: property.javaType,
          _name_: name
        })
      }
      content = beforeBlock + afterBlock
    })
    handleBlock('property', (beforeBlock, blockFormat, afterBlock) => {
      for (const name in properties) {
        const property = properties[name]
        beforeBlock += StringUtils.replaceAllInObj(blockFormat, {
          '_description_': property.description,
          '_category_': property.category,
          '/*_lineIf_designerVisible_*/': property.designerVisible ? '' : '//',
          '_setterVisible_': String(property.setterVisible),
          '_editorType_': property.editorType,
          '_args_': property.args.length === 0 ? '{}' : ('{"' + property.args.join('", "') + '"}'),
          '_type_': property.javaType,
          '_name_': name,
          '_getterVisible_': String(property.getterVisible)
        })
      }
      content = beforeBlock + afterBlock
    })
    handleBlock('elementComponent', (beforeBlock, blockFormat, afterBlock) => {
      function traverseComponentContainer (compProps: LvgItemLayout) {
        if (compProps.$Components !== undefined) {
          compProps.$Components.forEach(child => {
            beforeBlock += StringUtils.replaceAllInObj(blockFormat, {
              _type_: child.$Type,
              _name_: child.$Name
            })
            traverseComponentContainer(child)
          })
        }
      }
      traverseComponentContainer(itemLayout.Properties)
      content = beforeBlock + afterBlock
    })
    handlePlot('elementCreate', (beforePlot, linePrefix, afterPlot) => {
      function println (line = '') {
        beforePlot += line + '\n' + linePrefix
      }
      // FIXME: Handle different default values in different platforms
      function traverseComponentContainer (compProps: LvgItemLayout) {
        const containerName = compProps.$Type === 'Form' ? 'container' : compProps.$Name
        if (compProps.$Components !== undefined) {
          compProps.$Components.forEach(child => {
            println(StringUtils.replaceAllInObj('_name_ = new _type_(_container_)', {
              _type_: child.$Type,
              _name_: child.$Name,
              _container_: containerName
            }))
            for (const propName in child) {
              if (propName.charAt(0) !== '$' && propName !== 'Uuid') {
                println(StringUtils.replaceAllInObj('setProperty(_name_, "_propName_", "_propValue_")', {
                  _name_: child.$Name,
                  _propName_: propName,
                  _propValue_: child[propName]
                }))
              }
            }
            println()
            if (child.$Components !== null) {
              traverseComponentContainer(child)
            }
          })
        }
      }
      traverseComponentContainer(itemLayout.Properties)
      content = beforePlot + afterPlot
    })
    handlePlot('elementShow', (beforePlot, linePrefix, afterPlot) => {
      if (itemLayout.Properties.$Components !== undefined) {
        itemLayout.Properties.$Components.forEach(child => {
          beforePlot += StringUtils.replaceAllInObj('setProperty(_name_, "Visible", "true")', {
            _name_: child.$Name
          })
          beforePlot += '\n' + linePrefix
        })
        content = beforePlot + afterPlot
      }
    })
    handlePlot('elementHide', (beforePlot, linePrefix, afterPlot) => {
      if (itemLayout.Properties.$Components !== undefined) {
        itemLayout.Properties.$Components.forEach(child => {
          beforePlot += StringUtils.replaceAllInObj('setProperty(_name_, "Visible", "false")', {
            _name_: child.$Name
          })
          beforePlot += '\n' + linePrefix
        })
        content = beforePlot + afterPlot
      }
    })

    // TODO: handle more

    // TODO: remove this; this pretend it takes a longer time
    await new Promise(resolve => setTimeout(resolve, 1000))

    return generateInfo + content
  }

  private async onCopy () {
    try {
      this.$copyText(this.javaCode, this.$refs.codeContainer)
      this.$alertify.success(this.$t('modal.javaPreview.copied'))
    } catch (e) {
      this.$alertify.error(this.$t('modal.javaPreview.copyFailed'))
    }
  }
}
</script>

<style>
.code-container {
  height: 70vh;
}
.code-container pre {
  height: 100%;
}
.code-container code {
  width: fit-content;
  overflow: unset;
}
</style>