<template>
  <b-modal
      :title="$t('modal.previewJava.title')"
      centered
      size="lg"
      :ok-title="$t('button.dismiss')"
      :cancel-title="$t('button.copy')"
      ok-variant="primary"
      cancel-variant="secondary"
      :cancel-disabled="false"
      @cancel.prevent="onCopy">
    <div ref="codeContainer" class="code-container">
      <highlight-code lang="java" :code="javaCode" />
    </div>
  </b-modal>
</template>

<script>
import pkg from "../../../package.json"

import stringUtils from '../../utils/stringUtils';
import fileUtils from '../../utils/fileUtils';

export default {
  name: "JavaPreviewModal",
  data() {
    return {
      template: "",
      zipObject: {},
      javaCode: ""
    }
  },
  methods: {
    onCopy() {
      this.$copyText(this.javaCode, this.$refs.codeContainer)
      .then(() => this.$alertify.success(this.$t("modal.javaPreview.copied")),
            () => this.$alertify.success(this.$t("modal.javaPreview.copyFailed")));
    },
    showModal(template, zipObject) {
      if (template == null || zipObject == null) {
        return new Promise((r, reject) => reject("null reference"));
      }
      this.template = template;
      this.zipObject = zipObject;
      this.javaCode = this.$t("modal.javaPreview.generating");
      this.generateCode(template, zipObject)
      .then(val => {
        this.javaCode = val;
      }, err => {
        this.javaCode = this.$t("modal.javaPreview.failedGenerating") + err;
      });
      this.$children[0].show()
    },
    generateCode(template, projectObject) {
      return new Promise(resolve => {
        let generateInfo = ""
          + "/**\n"
          + " * This file is generated by ListView Generator(" + pkg.version + ") by ColinTree\n"
          + " * Find more infomation on github: https://github.com/ColinTree/ListViewGenerator \n"
          + " * Generate time: " + new Date(Date.now()) + "\n"
          + " * Browser: " + navigator.userAgent + "\n"
          + " * Location: " + window.location + "\n"
          + " */\n";

        let content = template;
        let projectInfo = projectObject.projectInfo;
        let itemLayout = projectObject.itemLayout;

        // replace globally: __xxx__
        content = stringUtils.replaceAllInObj(content, {
          "__componentName__": projectInfo.componentName,
          "__version__": projectInfo.version,
          "__fullPackage__": projectInfo.fullPackage,
          "__description__": projectInfo.description
        });

        // replace blocks: /*_blockStart_*/ ... /*_blockEnd_*/
        function handleBlock(content, blockName, handler) {
          let split = content.split("/*_"+blockName+"Start_*/");
          switch (split.length) {
            case 1:  throw "Template error: \"" + blockName + "\" start block not found";
            case 2:  break;
            default: throw "Template error: more than one \"" + blockName + "\" start block is found";
          }
          let beforeBlock = split[0] + "/* GENERATED BLOCK START: " + blockName + " */";
          split = split[1].split("/*_"+blockName+"End_*/");
          switch (split.length) {
            case 1:  throw "Template error: \""+blockName+"\" end block not found";
            case 2:  break;
            default: throw "Template error: more than one \""+blockName+"\" end block is found";
          }
          let blockFormat = split[0];
          let afterBlock = "/* GENERATED BLOCK END:   " + blockName + " */" + split[1];
          handler(beforeBlock, blockFormat, afterBlock);
        }
        // replace plot: /*_plotName_*/
        function handlePlot(content, plotName, handler) {
          let split = content.split("/*_"+plotName+"_*/");
          switch (split.length) {
            case 1:  throw "Template error: \"" + plotName + "\" plot not found";
            case 2:  break;
            default: throw "Template error: more than one \"" + plotName + "\" plot is found";
          }
          let linePrefix = split[0].substr(split[0].lastIndexOf("\n") + 1);
          let beforePlot = split[0] + "/* GENERATED PLOT START: " + plotName + " */\n" + linePrefix;
          let afterPlot = "/* GENERATED PLOT END:   " + plotName + " */" + split[1];
          handler(beforePlot, linePrefix, afterPlot);
        }
        handleBlock(content, "propertyDefaultValue", (beforeBlock, blockFormat, afterBlock) => {
          for (let name in projectInfo.properties) {
            let property = projectInfo.properties[name];
            beforeBlock += stringUtils.replaceAllInObj(blockFormat, {
              "_type_": property.javaType,
              "_name_": name,
              "_defaultValue_": property.defaultValue
            });
          }
          content = beforeBlock + afterBlock;
        });
        handleBlock(content, "propertyField", (beforeBlock, blockFormat, afterBlock) => {
          for (let name in projectInfo.properties) {
            let property = projectInfo.properties[name];
            beforeBlock += stringUtils.replaceAllInObj(blockFormat, {
              "_type_": property.javaType,
              "_name_": name
            });
          }
          content = beforeBlock + afterBlock;
        });
        handleBlock(content, "property", (beforeBlock, blockFormat, afterBlock) => {
          for (let name in projectInfo.properties) {
            let property = projectInfo.properties[name];
            beforeBlock += stringUtils.replaceAllInObj(blockFormat, {
              "_description_": property.description,
              "_category_": property.category,
              "_if_designerVisible_": property.designerVisible ? "" : "//",
              "_setterVisible_": property.setterVisible,
              "_editorType_": property.editorType,
              "_args_": (() => {
                let rtn = "{";
                let first = true;
                for (let argIndex in property.args) {
                  first ? first = false : rtn += ", ";
                  rtn += "\"" + property.args[argIndex] + "\"";
                }
                return rtn + "}";
              })(),
              "_type_": property.javaType,
              "_name_": name,
              "_getterVisible_": property.getterVisible
            });
          }
          content = beforeBlock + afterBlock;
        });
        handlePlot(content, "elementCreate", (beforePlot, linePrefix, afterPlot) => {
          let plot = "";
          function println(line = "") {
            plot += line;
            plot += "\n" + linePrefix;
          };
          // FIXME: Handle different default values in different platforms
          function traverseComponentContainer(compProps) {
            let containerName = compProps["$Type"] == "Form" ? "container" : compProps["$Name"];
            for (let childIndex in compProps["$Components"]) {
              let child = compProps["$Components"][childIndex];
              // Type name = new Type(Container);
              println(child["$Type"] + " " + child["$Name"] + " = new " + child["$Type"] + "(" + containerName + ");");
              for (let propName in child) {
                if (propName.charAt(0) != "$" && propName != "Uuid" && child.hasOwnProperty(propName)) {
                  let propValue = child[propName];
                  if (Number.isNaN(Number.parseInt(propValue))) {
                    propValue = "\"" + propValue + "\"";
                  }
                  println(child["$Name"] + "." + propName + "(" + propValue + ");");
                }
              }
              println();
              if (child["$Components"] != null) {
                traverseComponentContainer(child);
              }
            }
          }
          traverseComponentContainer(itemLayout["Properties"]);
          content = beforePlot + plot + afterPlot;
        });

        // TODO:

        setTimeout(() => resolve(generateInfo + content), 1000);
      });
    }
  }
}
</script>

<style>
.code-container {
  height: 70vh;
}
.code-container pre {
  height: 100%;
}
.code-container code {
  width: fit-content;
  overflow: unset;
}
</style>